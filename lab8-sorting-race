public class SortingAlgorithms {

    /**
     * Implements the Selection Sort algorithm.
     * Theoretical Complexity: O(n^2)
     */
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            // Swap the found minimum with the first element
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }

    /**
     * Implements the Insertion Sort algorithm.
     * Theoretical Complexity: O(n^2)
     * Best-Case: O(n)
     */
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            // Move elements greater than key to one position ahead
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }

    /**
     * Implements the Merge Sort algorithm. Public-facing method.
     * Theoretical Complexity: O(n log n)
     */
    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return; // Already sorted
        }
        int[] temp = new int[arr.length];
        mergeSortRecursive(arr, temp, 0, arr.length - 1);
    }

    private static void mergeSortRecursive(int[] arr, int[] temp, int left, int right) {
        if (left >= right) return;
        int mid = (left + right) / 2;
        mergeSortRecursive(arr, temp, left, mid);
        mergeSortRecursive(arr, temp, mid + 1, right);
        merge(arr, temp, left, mid, right);
    }

    private static void merge(int[] arr, int[] temp, int left, int mid, int right) {
        int i = left;
        int j = mid + 1;
        int k = left;

        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }

        while (i <= mid) temp[k++] = arr[i++];
        while (j <= right) temp[k++] = arr[j++];

        // Copy merged result back into original array
        for (int l = left; l <= right; l++) {
            arr[l] = temp[l];
        }
    }
}

import javax.swing.*;
import java.awt.*;
import java.util.Arrays;
import java.util.Random;

public class SortingTester {

    public static void main(String[] args) {
        int[] sizes = {1000, 5000, 10000, 25000, 50000};

        double[] selectionTimes = new double[sizes.length];
        double[] insertionTimes = new double[sizes.length];
        double[] mergeTimes = new double[sizes.length];

        System.out.println("--- Sorting Algorithm Performance ---");

        for (int i = 0; i < sizes.length; i++) {
            int n = sizes[i];
            int[] avg = generateRandomArray(n);

            selectionTimes[i] = timeAlgorithm(SortingAlgorithms::selectionSort, avg.clone());
            insertionTimes[i] = timeAlgorithm(SortingAlgorithms::insertionSort, avg.clone());
            mergeTimes[i] = timeAlgorithm(SortingAlgorithms::mergeSort, avg.clone());

            System.out.printf("n = %-6d | Selection: %.2f ms | Insertion: %.2f ms | Merge: %.2f ms%n",
                    n, selectionTimes[i], insertionTimes[i], mergeTimes[i]);
        }

        // Display the chart
        showChart(sizes, selectionTimes, insertionTimes, mergeTimes);
    }

    // Measure time
    private static double timeAlgorithm(java.util.function.Consumer<int[]> sorter, int[] arr) {
        long start = System.nanoTime();
        sorter.accept(arr);
        long end = System.nanoTime();
        return (end - start) / 1_000_000.0; // milliseconds
    }

    // Generate arrays
    public static int[] generateRandomArray(int size) {
        Random rand = new Random();
        int[] arr = new int[size];
        for (int i = 0; i < size; i++) arr[i] = rand.nextInt(size);
        return arr;
    }

    // Display chart in a JFrame
    private static void showChart(int[] sizes, double[] selection, double[] insertion, double[] merge) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Sorting Algorithm Performance");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.add(new ChartPanel(sizes, selection, insertion, merge));
            frame.setSize(800, 500);
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }

    // Inner class to draw the chart
    static class ChartPanel extends JPanel {
        int[] sizes;
        double[] selection, insertion, merge;

        public ChartPanel(int[] sizes, double[] selection, double[] insertion, double[] merge) {
            this.sizes = sizes;
            this.selection = selection;
            this.insertion = insertion;
            this.merge = merge;
        }

        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2 = (Graphics2D) g;

            int width = getWidth();
            int height = getHeight();
            int margin = 60;
            double maxTime = Math.max(Math.max(max(selection), max(insertion)), max(merge));

            // Axes
            g2.drawLine(margin, height - margin, width - margin, height - margin);
            g2.drawLine(margin, margin, margin, height - margin);

            // Labels
            g2.drawString("Input Size (n)", width / 2 - 30, height - 20);
            g2.drawString("Execution Time (ms)", 10, 30);

            // Plot lines
            drawLine(g2, sizes, selection, Color.RED, "Selection Sort", width, height, margin, maxTime);
            drawLine(g2, sizes, insertion, Color.BLUE, "Insertion Sort", width, height, margin, maxTime);
            drawLine(g2, sizes, merge, Color.GREEN.darker(), "Merge Sort", width, height, margin, maxTime);
        }

        private void drawLine(Graphics2D g2, int[] sizes, double[] times, Color color, String label,
                              int width, int height, int margin, double maxTime) {
            g2.setColor(color);
            int prevX = -1, prevY = -1;
            int usableWidth = width - 2 * margin;
            int usableHeight = height - 2 * margin;

            for (int i = 0; i < sizes.length; i++) {
                int x = margin + (int) ((double) i / (sizes.length - 1) * usableWidth);
                int y = height - margin - (int) ((times[i] / maxTime) * usableHeight);

                g2.fillOval(x - 3, y - 3, 6, 6);
                if (prevX != -1) g2.drawLine(prevX, prevY, x, y);
                prevX = x;
                prevY = y;
            }

            g2.drawString(label, width - 180, margin + (color == Color.RED ? 20 :
                    color == Color.BLUE ? 40 : 60));
        }

        private double max(double[] arr) {
            double m = arr[0];
            for (double v : arr) if (v > m) m = v;
            return m;
        }
    }
}

